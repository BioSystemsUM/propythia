

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>propythia.adjuv_functions.features_functions.descriptors_modlamp &mdash; ProPythia 0.04 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> ProPythia
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart.html">here will be a mega pretty file explaining everything</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../src.html">Source Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../guides.html">Guides</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ProPythia</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>propythia.adjuv_functions.features_functions.descriptors_modlamp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for propythia.adjuv_functions.features_functions.descriptors_modlamp</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. currentmodule:: modlamp.pydpi_py3</span>

<span class="sd">.. moduleauthor:: modlab Alex Mueller ETH Zurich &lt;alex.mueller@pharma.ethz.ch&gt;</span>

<span class="sd">This module incorporates different classes to calculate peptide descriptor values. The following classes are available:</span>

<span class="sd">=============================        ============================================================================</span>
<span class="sd">Class                                Characteristics</span>
<span class="sd">=============================        ============================================================================</span>
<span class="sd">:py:class:`GlobalDescriptor`         Global one-dimensional peptide pydpi_py3 calculated from the AA sequence.</span>
<span class="sd">:py:class:`PeptideDescriptor`        AA scale based global or convoluted pydpi_py3 (auto-/cross-correlated).</span>
<span class="sd">=============================        ============================================================================</span>

<span class="sd">.. seealso:: :class:`modlamp.core.BaseDescriptor` from which the classes in :mod:`modlamp.pydpi_py3` inherit.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="c1"># from sklearn.externals.joblib import Parallel, delayed</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="kn">from</span> <span class="nn">propythia.adjuv_functions.features_functions.modlamp_core</span> <span class="kn">import</span> <span class="n">BaseDescriptor</span><span class="p">,</span> <span class="n">load_scale</span><span class="p">,</span> <span class="n">count_aas</span><span class="p">,</span> <span class="n">aa_weights</span><span class="p">,</span> <span class="n">aa_energies</span><span class="p">,</span> <span class="n">aa_formulas</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Alex MÃ¼ller, Gisela Gabernet&quot;</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>


<span class="k">def</span> <span class="nf">_one_autocorr</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private function used for calculating auto-correlated pydpi for 1 given sequence, window and an AA scale.</span>
<span class="sd">    This function is used by the :py:func:`calculate_autocorr` method of :py:class:`PeptideDescriptor`.</span>

<span class="sd">    :param seq: {str} amino acid sequence to calculate descriptor for</span>
<span class="sd">    :param window: {int} correlation-window size</span>
<span class="sd">    :param scale: {str} amino acid scale to be used to calculate descriptor</span>
<span class="sd">    :return: {numpy.array} calculated descriptor data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># list of lists to store translated sequence values</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
        <span class="c1"># auto-correlation in defined sequence window</span>
        <span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c1"># for all correlation distances</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for all features of the descriptor scale</span>
                <span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                <span class="n">cntr</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># for every position in the sequence</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># check if corr distance is possible at that sequence position</span>
                        <span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counter to scale sum</span>
                        <span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span><span class="p">])</span>
                <span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c1"># append scaled correlation distance values</span>
        <span class="k">return</span> <span class="n">seqdesc</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR!</span><span class="se">\n</span><span class="s2">The chosen correlation window </span><span class="si">% i</span><span class="s2"> is larger than the sequence </span><span class="si">%s</span><span class="s2"> !&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
        

<span class="k">def</span> <span class="nf">_one_crosscorr</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Private function used for calculating cross-correlated pydpi_py3 for 1 given sequence, window and an AA scale.</span>
<span class="sd">    This function is used by the :py:func:`calculate_crosscorr` method of :py:class:`PeptideDescriptor`.</span>

<span class="sd">    :param seq: {str} amino acid sequence to calculate descriptor for</span>
<span class="sd">    :param window: {int} correlation-window size</span>
<span class="sd">    :param scale: {str} amino acid scale to be used to calculate descriptor</span>
<span class="sd">    :return: {numpy.array} calculated descriptor data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># list of lists to store translated sequence values</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
            <span class="n">m</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>
        <span class="c1"># auto-correlation in defined sequence window</span>
        <span class="n">seqdesc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for all features of the descriptor scale</span>
            <span class="k">for</span> <span class="n">cc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])):</span>  <span class="c1"># for every feature cross correlation</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]):</span>  <span class="c1"># check if corr distance is in range of the num of features</span>
                    <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>  <span class="c1"># for all correlation distances</span>
                        <span class="n">cntr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
                        <span class="n">valsum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># for every position in the sequence</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>  <span class="c1"># check if corr distance is possible at that sequence pos</span>
                                <span class="n">cntr</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># counter to scale sum</span>
                                <span class="n">valsum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">pos</span><span class="p">][</span><span class="n">val</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">dist</span><span class="p">][</span><span class="n">val</span> <span class="o">+</span> <span class="n">cc</span><span class="p">])</span>
                        <span class="n">seqdesc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">valsum</span><span class="p">)</span> <span class="o">/</span> <span class="n">cntr</span><span class="p">)</span>  <span class="c1"># append scaled correlation distance values</span>
        <span class="k">return</span> <span class="n">seqdesc</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR!</span><span class="se">\n</span><span class="s2">The chosen correlation window </span><span class="si">% i</span><span class="s2"> is larger than the sequence </span><span class="si">%s</span><span class="s2"> !&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_one_arc</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Privat function used for calculating arc pydpi_py3 for one sequence and AA scale. This function is used by</span>
<span class="sd">    :py:func:`calculate_arc` method method of :py:class:`PeptideDescriptor`.</span>

<span class="sd">    :param seq: {str} amino acid sequence to calculate descriptor for</span>
<span class="sd">    :param scale: {str} amino acid scale to be used to calculate descriptor</span>
<span class="sd">    :return: {numpy.array} calculated descriptor data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_mat</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="n">desc_mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="n">aa</span><span class="p">])</span>
    <span class="n">desc_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc_mat</span><span class="p">)</span>

    <span class="c1"># Check descriptor dimension</span>
    <span class="n">desc_dim</span> <span class="o">=</span> <span class="n">desc_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># list to store descriptor values for all windows</span>
    <span class="n">allwindows_arc</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="mi">18</span>
        <span class="c1"># calculates number of windows in sequence</span>
        <span class="n">num_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">num_windows</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># loop through all windows</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_windows</span><span class="p">):</span>
        <span class="c1"># slices descriptor matrix into current window</span>
        <span class="n">window_mat</span> <span class="o">=</span> <span class="n">desc_mat</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">window</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># defines order of amino acids in helical projection</span>
        <span class="n">order</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>

        <span class="c1"># orders window descriptor matrix into helical projection order</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ordered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_mat</span><span class="p">[</span><span class="n">pos</span><span class="p">,</span> <span class="p">:])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># for sequences of len &lt; 18 adding dummy vector with 2s, length of descriptor dimensions</span>
                <span class="n">ordered</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">desc_dim</span><span class="p">)</span>
        <span class="n">ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ordered</span><span class="p">)</span>

        <span class="n">window_arc</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through pharmacophoric features</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">desc_dim</span><span class="p">):</span>
            <span class="n">all_arcs</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># stores all arcs that can be found of a pharmacophoric feature</span>
            <span class="n">arc</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">18</span><span class="p">):</span>  <span class="c1"># for all positions in helix, regardless of sequence length</span>
                <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if position does not contain pharmacophoric feature</span>
                    <span class="n">all_arcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>  <span class="c1"># append previous arc to all arcs list</span>
                    <span class="n">arc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># arc is initialized</span>
                <span class="k">elif</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if position contains pharmacophoric feature(PF), elongate arc by 20Â°</span>
                    <span class="n">arc</span> <span class="o">+=</span> <span class="mi">20</span>
                <span class="k">elif</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># if position doesn&#39;t contain amino acid:</span>
                    <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if previous position contained PF add 10Â°</span>
                        <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>
                    <span class="k">elif</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if previous position didn&#39;t contain PF don&#39;t add anything</span>
                        <span class="n">arc</span> <span class="o">+=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">ordered</span><span class="p">[</span>
                                <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if previous position is empty then check second previous for PF</span>
                        <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">17</span><span class="p">:</span>  <span class="c1"># if we are at the last position check for position n=0 instead of next position.</span>
                        <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># if it contains PF add 10Â° extra</span>
                            <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># if next position contains PF add 10Â° extra</span>
                        <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>
                        <span class="k">elif</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">arc</span> <span class="o">+=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if next position is empty check for 2nd next position</span>
                            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">ordered</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">arc</span> <span class="o">+=</span> <span class="mi">10</span>

            <span class="n">all_arcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">arc</span> <span class="o">==</span> <span class="mi">360</span><span class="p">:</span>
                <span class="n">arc0</span> <span class="o">=</span> <span class="n">all_arcs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">+</span> <span class="n">all_arcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># join first and last arc together</span>
                <span class="n">all_arcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arc0</span><span class="p">]</span> <span class="o">+</span> <span class="n">all_arcs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="n">window_arc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">all_arcs</span><span class="p">))</span>  <span class="c1"># append to window arcs the maximum arc of this PF</span>
        <span class="n">allwindows_arc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">window_arc</span><span class="p">)</span>  <span class="c1"># append all PF arcs of this window</span>

    <span class="n">allwindows_arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">allwindows_arc</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
        <span class="n">final_arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">allwindows_arc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># calculate maximum / mean arc along all windows</span>
    <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
        <span class="n">final_arc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">allwindows_arc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;modality is unknown, please choose between &quot;max&quot; and &quot;mean&quot;</span><span class="se">\n</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">final_arc</span>


<span class="k">def</span> <span class="nf">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates charge of a single sequence. The method used is first described by Bjellqvist. In the case of</span>
<span class="sd">    amidation, the value for the  &#39;Cterm&#39; pKa is 15 (and Cterm is added to the pos_pks dictionary.</span>
<span class="sd">    The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">    **pos_pks** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">    **neg_pks** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">    :param ph: {float} pH at which to calculate peptide charge.</span>
<span class="sd">    :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">    :return: {array} descriptor values in the attribute :py:attr:`descriptor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">amide</span><span class="p">:</span>
        <span class="n">pos_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
        <span class="n">neg_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">15.</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Nterm&#39;</span><span class="p">:</span> <span class="mf">9.38</span><span class="p">,</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="mf">10.67</span><span class="p">,</span> <span class="s1">&#39;R&#39;</span><span class="p">:</span> <span class="mf">12.10</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mf">6.04</span><span class="p">}</span>
        <span class="n">neg_pks</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Cterm&#39;</span><span class="p">:</span> <span class="mf">2.15</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mf">3.71</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mf">4.15</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mf">8.14</span><span class="p">,</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span> <span class="mf">10.10</span><span class="p">}</span>
    
    <span class="n">aa_content</span> <span class="o">=</span> <span class="n">count_aas</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;absolute&#39;</span><span class="p">)</span>
    <span class="n">aa_content</span><span class="p">[</span><span class="s1">&#39;Nterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">aa_content</span><span class="p">[</span><span class="s1">&#39;Cterm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">pos_charge</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">pos_pks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_r</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">pK</span> <span class="o">-</span> <span class="n">ph</span><span class="p">)</span>
        <span class="n">partial_charge</span> <span class="o">=</span> <span class="n">c_r</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_r</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">pos_charge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
    <span class="n">neg_charge</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">aa</span><span class="p">,</span> <span class="n">pK</span> <span class="ow">in</span> <span class="n">neg_pks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">c_r</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">ph</span> <span class="o">-</span> <span class="n">pK</span><span class="p">)</span>
        <span class="n">partial_charge</span> <span class="o">=</span> <span class="n">c_r</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_r</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">neg_charge</span> <span class="o">+=</span> <span class="n">aa_content</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">*</span> <span class="n">partial_charge</span>
    <span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">pos_charge</span> <span class="o">-</span> <span class="n">neg_charge</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<div class="viewcode-block" id="GlobalDescriptor"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor">[docs]</a><span class="k">class</span> <span class="nc">GlobalDescriptor</span><span class="p">(</span><span class="n">BaseDescriptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for global, non-amino acid scale dependant pydpi_py3. The following pydpi_py3 can be calculated by</span>
<span class="sd">    the **methods** linked below:</span>

<span class="sd">    - `Sequence Length      &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.length&gt;`_</span>
<span class="sd">    - `Molecular Formula    &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.formula&gt;`_</span>
<span class="sd">    - `Molecular Weight     &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.calculate_MW&gt;`_</span>
<span class="sd">    - `Sequence Charge      &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.calculate_charge&gt;`_</span>
<span class="sd">    - `Charge Density       &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.charge_density&gt;`_</span>
<span class="sd">    - `Isoelectric Point    &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.isoelectric_point&gt;`_</span>
<span class="sd">    - `Instability Index    &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.instability_index&gt;`_</span>
<span class="sd">    - `Aromaticity          &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.aromaticity&gt;`_</span>
<span class="sd">    - `Aliphatic Index      &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.aliphatic_index&gt;`_</span>
<span class="sd">    - `Boman Index          &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.boman_index&gt;`_</span>
<span class="sd">    - `Hydrophobic Ratio    &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.hydrophobic_ratio&gt;`_</span>
<span class="sd">    - `all of the above     &lt;modlamp.html#modlamp.pydpi_py3.GlobalDescriptor.calculate_all&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="GlobalDescriptor.length"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.length">[docs]</a>    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the length (total AA count) of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of sequence lengths in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor([&#39;AFDGHLKI&#39;,&#39;KKLQRSDLLRTK&#39;,&#39;KKLASCNNIPPR&#39;])</span>
<span class="sd">        &gt;&gt;&gt; desc.length()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 8.], [12.], [12.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Length&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Length&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.formula"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.formula">[docs]</a>    <span class="k">def</span> <span class="nf">formula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the molecular formula of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        </span>
<span class="sd">        :param amide: {boolean} whether the sequences are C-terminally amidated.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of molecular formulas {str} in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor([&#39;KADSFLSADGHSADFSLDKKLKERL&#39;, &#39;ERTILSDFPQWWFASLDFLNC&#39;, &#39;ACDEFGHIKLMNPQRSTVWY&#39;])</span>
<span class="sd">        &gt;&gt;&gt; desc.formula(amide=True)</span>
<span class="sd">        &gt;&gt;&gt; for v in desc.descriptor:</span>
<span class="sd">        ...     print(v[0])</span>
<span class="sd">        C122 H197 N35 O39</span>
<span class="sd">        C121 H168 N28 O33 S</span>
<span class="sd">        C106 H157 N29 O30 S2</span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :py:func:`modlamp.core.aa_formulas()`</span>
<span class="sd">        </span>
<span class="sd">        .. versionadded:: v2.7.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">formulas</span> <span class="o">=</span> <span class="n">aa_formulas</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>  <span class="c1"># sum over aa weights</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">f</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">formulas</span><span class="p">[</span><span class="n">aa</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            
            <span class="c1"># substract H2O for every peptide bond</span>
            <span class="n">f</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">f</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">amide</span><span class="p">:</span>  <span class="c1"># add C-terminal amide --&gt; replace OH with NH2</span>
                <span class="n">f</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">f</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="s1">&#39;C</span><span class="si">%s</span><span class="s1"> H</span><span class="si">%s</span><span class="s1"> N</span><span class="si">%s</span><span class="s1"> O</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">],</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="s1">&#39;C</span><span class="si">%s</span><span class="s1"> H</span><span class="si">%s</span><span class="s1"> N</span><span class="si">%s</span><span class="s1"> O</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;H&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">])</span>
                
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Formula&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Formula&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_MW"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.calculate_MW">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_MW</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the molecular weight [g/mol] of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        :param amide: {boolean} whether the sequences are C-terminally amidated (subtracts 0.95 from the MW).</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;IAESFKGHIPL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.calculate_MW(amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 1210.43]])</span>

<span class="sd">        .. seealso:: :py:func:`modlamp.core.aa_weights()`</span>

<span class="sd">        .. versionchanged:: v2.1.5 amide option added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">mw</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>  <span class="c1"># sum over aa weights</span>
                <span class="n">mw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">aa</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mw</span><span class="p">)</span> <span class="o">-</span> <span class="mf">18.015</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum over AA MW and subtract H20 MW for every</span>
            <span class="c1"># peptide bond</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">amide</span><span class="p">:</span>  <span class="c1"># if sequences are amidated, subtract 0.98 from calculated MW (OH - NH2)</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="o">-</span> <span class="mf">0.98</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">desc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;MW&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MW&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_charge"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.calculate_charge">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to overall charge of every sequence in the attribute :py:attr:`sequences`.</span>

<span class="sd">        The method used is first described by Bjellqvist. In the case of amidation, the value for the &#39;Cterm&#39; pKa is 15</span>
<span class="sd">        (and Cterm is added to the pos_pKs dictionary.</span>
<span class="sd">        The pKa scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">        **pos_pKs** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">        **neg_pKs** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">        :param ph: {float} ph at which to calculate peptide charge.</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KLAKFGKRSELVALSG&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.calculate_charge(ph=7.4, amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 3.989]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">))</span>  <span class="c1"># calculate charge with helper function</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Charge&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Charge&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.charge_density"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.charge_density">[docs]</a>    <span class="k">def</span> <span class="nf">charge_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the charge density (charge / MW) of every sequences in the attributes :py:attr:`sequences`</span>

<span class="sd">        :param ph: {float} pH at which to calculate peptide charge.</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GNSDLLIEQRTLLASDEF&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.charge_density(ph=6, amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[-0.00097119]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_charge</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
        <span class="n">charges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_MW</span><span class="p">(</span><span class="n">amide</span><span class="p">)</span>
        <span class="n">masses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">charges</span> <span class="o">/</span> <span class="n">masses</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ChargeDensity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ChargeDensity&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.isoelectric_point"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.isoelectric_point">[docs]</a>    <span class="k">def</span> <span class="nf">isoelectric_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the isoelectric point of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        The pK scale is extracted from: http://www.hbcpnetbase.com/ (CRC Handbook of Chemistry and Physics, 96th ed).</span>

<span class="sd">         **pos_pKs** = {&#39;Nterm&#39;: 9.38, &#39;K&#39;: 10.67, &#39;R&#39;: 12.10, &#39;H&#39;: 6.04}</span>

<span class="sd">         **neg_pKs** = {&#39;Cterm&#39;: 2.15, &#39;D&#39;: 3.71, &#39;E&#39;: 4.15, &#39;C&#39;: 8.14, &#39;Y&#39;: 10.10}</span>

<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KLFDIKFGHIPQRST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.isoelectric_point()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 10.6796875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>

            <span class="c1"># Bracket between ph1 and ph2</span>
            <span class="n">ph</span> <span class="o">=</span> <span class="mf">7.0</span>
            <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
                <span class="k">while</span> <span class="n">charge1</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="n">ph1</span> <span class="o">+</span> <span class="mf">1.0</span>
                    <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="n">charge1</span> <span class="o">=</span> <span class="n">charge</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
                <span class="k">while</span> <span class="n">charge2</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph</span> <span class="o">=</span> <span class="n">ph2</span> <span class="o">-</span> <span class="mf">1.0</span>
                    <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">charge</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="n">charge2</span> <span class="o">=</span> <span class="n">charge</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                        <span class="k">break</span>
            <span class="c1"># Bisection</span>
            <span class="k">while</span> <span class="n">ph2</span> <span class="o">-</span> <span class="n">ph1</span> <span class="o">&gt;</span> <span class="mf">0.0001</span> <span class="ow">and</span> <span class="n">charge</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">ph</span> <span class="o">=</span> <span class="p">(</span><span class="n">ph1</span> <span class="o">+</span> <span class="n">ph2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">charge</span> <span class="o">=</span> <span class="n">_charge</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">charge</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">ph1</span> <span class="o">=</span> <span class="n">ph</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ph2</span> <span class="o">=</span> <span class="n">ph</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ph</span><span class="p">)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pI&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pI&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.instability_index"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.instability_index">[docs]</a>    <span class="k">def</span> <span class="nf">instability_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the instability of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        The instability index is a prediction of protein stability based on the amino acid composition.</span>
<span class="sd">        ([1] K. Guruprasad, B. V Reddy, M. W. Pandit, Protein Eng. 1990, 4, 155â161.)</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;LLASMNDLLAKRST&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.instability_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 63.95714286]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dimv</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="s1">&#39;instability&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">stabindex</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">stabindex</span> <span class="o">+=</span> <span class="n">dimv</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mf">10.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">*</span> <span class="n">stabindex</span><span class="p">)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;InstabilityInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;InstabilityInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aromaticity"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.aromaticity">[docs]</a>    <span class="k">def</span> <span class="nf">aromaticity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the aromaticity of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Lobry, 1994, it is simply the relative frequency of Phe+Trp+Tyr.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GLFYWRFFLQRRFLYWW&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.aromaticity()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 0.52941176]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">f</span> <span class="o">+</span> <span class="n">w</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Aromaticity&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Aromaticity&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.aliphatic_index"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.aliphatic_index">[docs]</a>    <span class="k">def</span> <span class="nf">aliphatic_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the aliphatic index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Ikai, 1980, the aliphatic index is a measure of thermal stability of proteins and is dependant</span>
<span class="sd">        on the relative volume occupied by aliphatic amino acids (A,I,L &amp; V).</span>
<span class="sd">        ([1] A. Ikai, J. Biochem. 1980, 88, 1895â1898.)</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;KWLKYLKKLAKLVK&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.aliphatic_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 139.28571429]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aa_dict</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">aa</span><span class="p">:</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aa_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c1"># count aa</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c1"># get mole percent of all AA</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.9</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">3.9</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]))</span>  <span class="c1"># formula for calculating the AI (Ikai, 1980)</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;AliphaticInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AliphaticInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.boman_index"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.boman_index">[docs]</a>    <span class="k">def</span> <span class="nf">boman_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to calculate the boman index of every sequence in the attribute :py:attr:`sequences`.</span>
<span class="sd">        According to Boman, 2003, the boman index is a measure for protein-protein interactions and is calculated by</span>
<span class="sd">        summing over all amino acid free energy of transfer [kcal/mol] between water and cyclohexane,[2] followed by</span>
<span class="sd">        dividing by    sequence length.</span>
<span class="sd">        ([1] H. G. Boman, D. Wade, I. a Boman, B. WÃ¥hlin, R. B. Merrifield, *FEBS Lett*. **1989**, *259*, 103â106.</span>
<span class="sd">        [2] A. Radzick, R. Wolfenden, *Biochemistry* **1988**, *27*, 1664â1670.)</span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :py:func:`modlamp.core.aa_energies()`</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;GLFDIVKKVVGALGSL&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.boman_index()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[-1.011875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">aa_energies</span><span class="p">()</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;BomanInd&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BomanInd&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.hydrophobic_ratio"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.hydrophobic_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">hydrophobic_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to calculate the hydrophobic ratio of every sequence in the attribute :py:attr:`sequences`, which is the</span>
<span class="sd">        relative frequency of the amino acids **A,C,F,I,L,M &amp; V**.</span>

<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;VALLYWRTVLLAIII&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.hydrophobic_ratio()</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 0.73333333]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aa_dict</span> <span class="o">=</span> <span class="n">aa_weights</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
            <span class="n">pa</span> <span class="o">=</span> <span class="p">{</span><span class="n">aa</span><span class="p">:</span> <span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="n">aa_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>  <span class="c1"># count aa</span>
            <span class="c1"># formula for calculating the AI (Ikai, 1980):</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pa</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pa</span><span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)))</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;HydrophRatio&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;HydrophRatio&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="GlobalDescriptor.calculate_all"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.GlobalDescriptor.calculate_all">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ph</span><span class="o">=</span><span class="mf">7.4</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method combining all global pydpi_py3 and appending them into the feature matrix in the attribute</span>
<span class="sd">        :py:attr:`descriptor`.</span>
<span class="sd">        </span>
<span class="sd">        :param ph: {float} pH at which to calculate peptide charge</span>
<span class="sd">        :param amide: {boolean} whether the sequences have an amidated C-terminus.</span>
<span class="sd">        :return: array of descriptor values in the attribute :py:attr:`descriptor`</span>
<span class="sd">        :Example:</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; desc = GlobalDescriptor(&#39;AFGHFKLKKLFIFGHERT&#39;)</span>
<span class="sd">        &gt;&gt;&gt; desc.calculate_all(amide=True)</span>
<span class="sd">        &gt;&gt;&gt; desc.featurenames</span>
<span class="sd">        [&#39;Length&#39;, &#39;MW&#39;, &#39;ChargeDensity&#39;, &#39;pI&#39;, &#39;InstabilityInd&#39;, &#39;Aromaticity&#39;, &#39;AliphaticInd&#39;, &#39;BomanInd&#39;, &#39;HydRatio&#39;]</span>
<span class="sd">        &gt;&gt;&gt; desc.descriptor</span>
<span class="sd">        array([[ 18.,  2.17559000e+03,   1.87167619e-03,   1.16757812e+01, ...  1.10555556e+00,   4.44444444e-01]])</span>
<span class="sd">        &gt;&gt;&gt; desc.save_descriptor(&#39;/path/to/outputfile.csv&#39;)  # save the descriptor data (with feature names header)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># This is a strange way of doing it. However, the append=True option excludes length and charge, no idea why!</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">()</span>  <span class="c1"># sequence length</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_MW</span><span class="p">(</span><span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">)</span>  <span class="c1"># molecular weight</span>
        <span class="n">mw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calculate_charge</span><span class="p">(</span><span class="n">ph</span><span class="o">=</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">)</span>  <span class="c1"># net charge</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charge_density</span><span class="p">(</span><span class="n">ph</span><span class="o">=</span><span class="n">ph</span><span class="p">,</span> <span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">)</span>  <span class="c1"># charge density</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isoelectric_point</span><span class="p">(</span><span class="n">amide</span><span class="o">=</span><span class="n">amide</span><span class="p">)</span>  <span class="c1"># pI</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instability_index</span><span class="p">()</span>  <span class="c1"># instability index</span>
        <span class="n">si</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aromaticity</span><span class="p">()</span>  <span class="c1"># global aromaticity</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aliphatic_index</span><span class="p">()</span>  <span class="c1"># aliphatic index</span>
        <span class="n">ai</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boman_index</span><span class="p">()</span>  <span class="c1"># Boman index</span>
        <span class="n">bi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hydrophobic_ratio</span><span class="p">()</span>  <span class="c1"># Hydrophobic ratio</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span>
        <span class="n">fn</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">cd</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">ai</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">hr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">featurenames</span> <span class="o">=</span> <span class="n">fn</span></div></div>


<div class="viewcode-block" id="PeptideDescriptor"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor">[docs]</a><span class="k">class</span> <span class="nc">PeptideDescriptor</span><span class="p">(</span><span class="n">BaseDescriptor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for peptide pydpi_py3. The following **amino acid descriptor scales** are available for descriptor</span>
<span class="sd">    calculation:</span>

<span class="sd">    - **AASI**           (An amino acid selectivity index scale for helical antimicrobial peptides, *[1] D. JuretiÄ, D. VukiceviÄ, N. IliÄ, N. Antcheva, A. Tossi, J. Chem. Inf. Model. 2009, 49, 2873â2882.*)</span>
<span class="sd">    - **ABHPRK**         (modlabs inhouse physicochemical feature scale (Acidic, Basic, Hydrophobic, Polar, aRomatic, Kink-inducer)</span>
<span class="sd">    - **argos**          (Argos hydrophobicity amino acid scale, *[2] Argos, P., Rao, J. K. M. &amp; Hargrave, P. A., Eur. J. Biochem. 2005, 128, 565â575.*)</span>
<span class="sd">    - **bulkiness**      (Amino acid side chain bulkiness scale, *[3] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170â201.*)</span>
<span class="sd">    - **charge_phys**    (Amino acid charge at pH 7.0 - Hystidine charge +0.1.)</span>
<span class="sd">    - **charge_acid**    (Amino acid charge at acidic pH - Hystidine charge +1.0.)</span>
<span class="sd">    - **cougar**         (modlabs inhouse selection of global peptide pydpi_py3)</span>
<span class="sd">    - **eisenberg**      (the Eisenberg hydrophobicity consensus amino acid scale, *[4] D. Eisenberg, R. M. Weiss, T. C. Terwilliger, W. Wilcox, Faraday Symp. Chem. Soc. 1982, 17, 109.*)</span>
<span class="sd">    - **Ez**             (potential that assesses energies of insertion of amino acid side chains into lipid bilayers, *[5] A. Senes, D. C. Chadi, P. B. Law, R. F. S. Walters, V. Nanda, W. F. DeGrado, J. Mol. Biol. 2007, 366, 436â448.*)</span>
<span class="sd">    - **flexibility**    (amino acid side chain flexibilitiy scale, *[6] R. Bhaskaran, P. K. Ponnuswamy, Int. J. Pept. Protein Res. 1988, 32, 241â255.*)</span>
<span class="sd">    - **grantham**       (amino acid side chain composition, polarity and molecular volume, *[8] Grantham, R. Science. 185, 862â864 (1974).*)</span>
<span class="sd">    - **gravy**          (GRAVY hydrophobicity amino acid scale, *[9] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105â132.*)</span>
<span class="sd">    - **hopp-woods**     (Hopp-Woods amino acid hydrophobicity scale,*[10] T. P. Hopp, K. R. Woods, Proc. Natl. Acad. Sci. 1981, 78, 3824â3828.*)</span>
<span class="sd">    - **ISAECI**         (Isotropic Surface Area (ISA) and Electronic Charge Index (ECI) of amino acid side chains, *[11] E. R. Collantes, W. J. Dunn, J. Med. Chem. 1995, 38, 2705â2713.*)</span>
<span class="sd">    - **janin**          (Janin hydrophobicity amino acid scale, *[12] J. L. Cornette, K. B. Cease, H. Margalit, J. L. Spouge, J. A. Berzofsky, C. DeLisi, J. Mol. Biol. 1987, 195, 659â685.*)</span>
<span class="sd">    - **kytedoolittle**  (Kyte &amp; Doolittle hydrophobicity amino acid scale, *[13] J. Kyte, R. F. Doolittle, J. Mol. Biol. 1982, 157, 105â132.*)</span>
<span class="sd">    - **levitt_alpha**   (Levitt amino acid alpha-helix propensity scale, extracted from http://web.expasy.org/protscale. *[14] M. Levitt, Biochemistry 1978, 17, 4277-4285.*)</span>
<span class="sd">    - **MSS**            (A graph-theoretical index that reflects topological shape and size of amino acid side chains, *[15] C. Raychaudhury, A. Banerjee, P. Bag, S. Roy, J. Chem. Inf. Comput. Sci. 1999, 39, 248â254.*)</span>
<span class="sd">    - **MSW**            (Amino acid scale based on a pca of the molecular surface based WHIM descriptor (MS-WHIM), extended to natural amino acids, *[16] A. Zaliani, E. Gancia, J. Chem. Inf. Comput. Sci 1999, 39, 525â533.*)</span>
<span class="sd">    - **pepArc**         (modlabs pharmacophoric feature scale, dimensions are: hydrophobicity, polarity, positive charge, negative charge, proline.)</span>
<span class="sd">    - **pepcats**        (modlabs pharmacophoric feature based PEPCATS scale, *[17] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">    - **polarity**       (Amino acid polarity scale, *[18] J. M. Zimmerman, N. Eliezer, R. Simha, J. Theor. Biol. 1968, 21, 170â201.*)</span>
<span class="sd">    - **PPCALI**         (modlabs inhouse scale derived from a pca of 143 amino acid property scales, *[19] C. P. Koch, A. M. Perna, M. Pillong, N. K. Todoroff, P. Wrede, G. Folkers, J. A. Hiss, G. Schneider, PLoS Comput. Biol. 2013, 9, e1003088.*)</span>
<span class="sd">    - **refractivity**   (Relative amino acid refractivity values, *[20] T. L. McMeekin, M. Wilensky, M. L. Groves, Biochem. Biophys. Res. Commun. 1962, 7, 151â156.*)</span>
<span class="sd">    - **t_scale**        (A pca derived scale based on amino acid side chain properties calculated with 6 different probes of the GRID program, *[21] M. Cocchi, E. Johansson, Quant. Struct. Act. Relationships 1993, 12, 1â8.*)</span>
<span class="sd">    - **TM_tend**        (Amino acid transmembrane propensity scale, extracted from http://web.expasy.org/protscale, *[22] Zhao, G., London E. Protein Sci. 2006, 15, 1987-2001.*)</span>
<span class="sd">    - **z3**             (The original three dimensional Z-scale, *[23] S. Hellberg, M. SjÃ¶strÃ¶m, B. Skagerberg, S. Wold, J. Med. Chem. 1987, 30, 1126â1135.*)</span>
<span class="sd">    - **z5**             (The extended five dimensional Z-scale, *[24] M. Sandberg, L. Eriksson, J. Jonsson, M. SjÃ¶strÃ¶m, S. Wold, J. Med. Chem. 1998, 41, 2481â2491.*)</span>

<span class="sd">    Further, amino acid scale independent methods can be calculated with help of the :class:`GlobalDescriptor` class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">scalename</span><span class="o">=</span><span class="s1">&#39;Eisenberg&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param seqs: a .fasta file with sequences, a list of sequences or a single sequence as string to calculate the</span>
<span class="sd">            descriptor values for.</span>
<span class="sd">        :param scalename: {str} name of the amino acid scale (one of the given list above) used to calculate the</span>
<span class="sd">            descriptor values</span>
<span class="sd">        :return: initialized attributes :py:attr:`sequences`, :py:attr:`names` and dictionary :py:attr:`scale` with</span>
<span class="sd">            amino acid scale values of the scale name in :py:attr:`scalename`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKLLKLLK&#39;,&#39;pepcats&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.sequences</span>
<span class="sd">        [&#39;KLLKLLKKLLKLLK&#39;]</span>
<span class="sd">        &gt;&gt;&gt; seqs = PeptideDescriptor(&#39;/Path/to/file.fasta&#39;, &#39;eisenberg&#39;)  # load sequences from .fasta file</span>
<span class="sd">        &gt;&gt;&gt; seqs.sequences</span>
<span class="sd">        [&#39;AFDGHLKI&#39;,&#39;KKLQRSDLLRTK&#39;,&#39;KKLASCNNIPPR&#39;...]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PeptideDescriptor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="n">scalename</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># for passing hydrophobic moments to calculate_profile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>  <span class="c1"># for passing global  to calculate_profile</span>

<div class="viewcode-block" id="PeptideDescriptor.load_scale"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.load_scale">[docs]</a>    <span class="k">def</span> <span class="nf">load_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to load amino acid values from a given scale</span>

<span class="sd">        :param scalename: {str} name of the amino acid scale to be loaded.</span>
<span class="sd">        :return: loaded amino acid scale values in a dictionary in the attribute :py:attr:`scale`.</span>

<span class="sd">        .. seealso:: :func:`modlamp.core.load_scale()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scalename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">load_scale</span><span class="p">(</span><span class="n">scalename</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_autocorr"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_autocorr">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_autocorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for auto-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">        :param window: {int} correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: calculated descriptor numpy.array in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;PPCALI&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_autocorr(7)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[  1.28442339e+00,   1.29025116e+00,   1.03240901e+00, .... ]])</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">        (1, 133)</span>

<span class="sd">        .. versionchanged:: v.2.3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_one_autocorr</span><span class="p">)(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_crosscorr"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_crosscorr">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_crosscorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for cross-correlating the amino acid values for a given descriptor scale</span>

<span class="sd">        :param window: {int} correlation window for descriptor calculation in a sliding window approach</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: calculated descriptor numpy.array in the attribute :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;pepcats&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_crosscorr(7)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.6875    ,  0.46666667,  0.42857143,  0.61538462,  0.58333333, ... ]])</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor.shape</span>
<span class="sd">        (1, 147)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_one_crosscorr</span><span class="p">)(</span><span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_moment"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_moment">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating the maximum or mean moment of the amino acid values for a given descriptor scale and</span>
<span class="sd">        window.</span>

<span class="sd">        :param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the</span>
<span class="sd">            window, the length of the sequence is taken. So if the default window of 1000 is chosen, for all sequences</span>
<span class="sd">            shorter than 1000, the **global** hydrophobic moment will be calculated. Otherwise, the maximal</span>
<span class="sd">            hydrophiobic moment for the chosen window size found in the sequence will be returned.</span>
<span class="sd">        :param angle: {int} angle in which to calculate the moment. **100** for alpha helices, **180** for beta sheets.</span>
<span class="sd">        :param modality: {&#39;all&#39;, &#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment. If all,</span>
<span class="sd">            moments for all windows are returned.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Calculated descriptor as a numpy.array in the attribute :py:attr:`descriptor` and all possible global</span>
<span class="sd">            values in :py:attr:`all_moms` (needed for the :py:func:`calculate_profile` method)</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;, &#39;eisenberg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_moment()</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.48790226]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Descriptor moment calculation is only possible for one dimensional pydpi_py3.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>
                <span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>  <span class="c1"># if sequence is shorter than window, take the whole sequence instead</span>
                <span class="n">mtrx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">mwdw</span> <span class="o">=</span> <span class="p">[]</span>
                
                <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
                    <span class="n">mtrx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">aa</span><span class="p">])])</span>
                    
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mtrx</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mtrx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],</span> <span class="p">[]))</span>
    
                <span class="n">mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mwdw</span><span class="p">)</span>
                <span class="n">rads</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">wdw</span><span class="p">))</span>  <span class="c1"># calculate actual moment (radial)</span>
                <span class="n">vcos</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">vsin</span> <span class="o">=</span> <span class="p">(</span><span class="n">mwdw</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">rads</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">moms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">vsin</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">vcos</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">wdw</span>
    
                <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>  <span class="c1"># take window with maximal value</span>
                    <span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>  <span class="c1"># take average value over all windows</span>
                    <span class="n">moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
                    <span class="n">moment</span> <span class="o">=</span> <span class="n">moms</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">ERROR!</span><span class="se">\n</span><span class="s1">Modality parameter is wrong, please choose between &quot;all&quot;, &quot;max&quot; and &quot;mean&quot;.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moment</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moms</span><span class="p">)</span>
                
            <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># final descriptor array</span>
            
            <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_global"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_global">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating a global / window averaging descriptor value of a given AA scale</span>

<span class="sd">        :param window: {int} amino acid window in which to calculate the moment. If the sequence is shorter than the</span>
<span class="sd">            window, the length of the sequence is taken.</span>
<span class="sd">        :param modality: {&#39;max&#39; or &#39;mean&#39;} Calculate respectively maximum or mean hydrophobic moment.</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Calculated descriptor as a numpy.array in the attribute :py:attr:`descriptor` and all possible global</span>
<span class="sd">            values in :py:attr:`all_globs` (needed for the :py:func:`calculate_profile` method)</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;GLFDIVKKVVGALGSL&#39;,&#39;eisenberg&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_global(window=1000, modality=&#39;max&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.44875]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
            <span class="n">wdw</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>  <span class="c1"># if sequence is shorter than window, take the whole sequence instead</span>
            <span class="n">mtrx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mwdw</span> <span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>  <span class="c1"># translate AA sequence into values</span>
                <span class="n">mtrx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mtrx</span><span class="p">)</span> <span class="o">-</span> <span class="n">wdw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">mwdw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">mtrx</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">wdw</span><span class="p">],</span> <span class="p">[]))</span>  <span class="c1"># list of all the values for the different windows</span>
                
            <span class="n">mwdw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mwdw</span><span class="p">)</span>
            <span class="n">glob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mwdw</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">wdw</span><span class="p">)</span>
            <span class="n">outglob</span> <span class="o">=</span> <span class="nb">float</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">modality</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
                    <span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c1"># returned moment will be the maximum of all windows</span>
                <span class="k">elif</span> <span class="n">modality</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="n">outglob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>  <span class="c1"># returned moment will be the mean of all windows</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Modality parameter is wrong, please choose between &quot;max&quot; and &quot;mean&quot;</span><span class="se">\n</span><span class="s1">.&#39;</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outglob</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glob</span><span class="p">)</span>
        
        <span class="n">desc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_profile"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_profile">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prof_type</span><span class="o">=</span><span class="s1">&#39;uH&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for calculating hydrophobicity or hydrophobic moment profiles for given sequences and fitting for</span>
<span class="sd">        slope and intercept. The hydrophobicity scale used is &quot;eisenberg&quot;</span>

<span class="sd">        :param prof_type: prof_type of profile, available: &#39;H&#39; for hydrophobicity or &#39;uH&#39; for hydrophobic moment</span>
<span class="sd">        :param window: {int} size of sliding window used (odd-numbered).</span>
<span class="sd">        :param append: {boolean} whether the produced descriptor values should be appended to the existing ones in the</span>
<span class="sd">            attribute :py:attr:`descriptor`.</span>
<span class="sd">        :return: Fitted slope and intercept of calculated profile for every given sequence in the attribute</span>
<span class="sd">            :py:attr:`descriptor`.</span>
<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; AMP = PeptideDescriptor(&#39;KLLKLLKKVVGALG&#39;,&#39;kytedoolittle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.calculate_profile(prof_type=&#39;H&#39;)</span>
<span class="sd">        &gt;&gt;&gt; AMP.descriptor</span>
<span class="sd">        array([[ 0.03731293,  0.19246599]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prof_type</span> <span class="o">==</span> <span class="s1">&#39;uH&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_moment</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_moms</span>
        <span class="k">elif</span> <span class="n">prof_type</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_global</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_globs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;prof_type parameter is unknown, choose &quot;uH&quot; for hydrophobic moment or &quot;H&quot; for hydrophobicity</span><span class="se">\n</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

        <span class="n">desc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">):</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))[</span><span class="nb">int</span><span class="p">((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span><span class="o">-</span><span class="nb">int</span><span class="p">((</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">:</span>
                <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">desc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="PeptideDescriptor.calculate_arc"><a class="viewcode-back" href="../../../../propythia.adjuv_functions.features_functions.html#propythia.adjuv_functions.features_functions.descriptors_modlamp.PeptideDescriptor.calculate_arc">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_arc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">modality</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for calculating property arcs as seen in the helical wheel plot. Use for binary amino acid scales only.</span>
<span class="sd">        </span>
<span class="sd">        :param modality: modality of the arc to calculate, to choose between &quot;max&quot; and &quot;mean&quot;.</span>
<span class="sd">        :param append: if true, append to current descriptor stored in the descriptor attribute.</span>
<span class="sd">        :return: calculated descriptor as numpy.array in the descriptor attribute.</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; arc = PeptideDescriptor(&quot;KLLKLLKKLLKLLK&quot;, scalename=&quot;peparc&quot;)</span>
<span class="sd">        &gt;&gt;&gt; arc.calculate_arc(modality=&quot;max&quot;, append=False)</span>
<span class="sd">        &gt;&gt;&gt; arc.descriptor</span>
<span class="sd">        array([[200, 160, 160,   0,   0]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">_one_arc</span><span class="p">)(</span><span class="n">seq</span><span class="p">,</span> <span class="n">modality</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">)</span>

        <span class="c1"># Converts each of the amino acids to descriptor vector</span>
        <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequences</span><span class="p">:</span>

            <span class="c1"># desc_mat = []</span>
            <span class="c1"># for aa in seq:</span>
            <span class="c1">#     desc_mat.append(self.scale[aa])</span>
            <span class="c1"># desc_mat = np.asarray(desc_mat)</span>
			<span class="c1">#</span>
            <span class="c1"># # Check descriptor dimension</span>
            <span class="c1"># desc_dim = desc_mat.shape[1]</span>
			<span class="c1">#</span>
            <span class="c1"># # list to store descriptor values for all windows</span>
            <span class="c1"># allwindows_arc = []</span>
			<span class="c1">#</span>
            <span class="c1"># if len(seq) &gt; 18:</span>
            <span class="c1">#     window = 18</span>
            <span class="c1">#     # calculates number of windows in sequence</span>
            <span class="c1">#     num_windows = len(seq) - window</span>
            <span class="c1"># else:</span>
            <span class="c1">#     window = len(seq)</span>
            <span class="c1">#     num_windows = 1</span>
			<span class="c1">#</span>
            <span class="c1"># # loop through all windows</span>
            <span class="c1"># for j in range(num_windows):</span>
            <span class="c1">#     # slices descriptor matrix into current window</span>
            <span class="c1">#     window_mat = desc_mat[j:j + window, :]</span>
			<span class="c1">#</span>
            <span class="c1">#     # defines order of amino acids in helical projection</span>
            <span class="c1">#     order = [0, 11, 4, 15, 8, 1, 12, 5, 16, 9, 2, 13, 6, 17, 10, 3, 14, 7]</span>
			<span class="c1">#</span>
            <span class="c1">#     # orders window descriptor matrix into helical projection order</span>
            <span class="c1">#     ordered = []</span>
            <span class="c1">#     for pos in order:</span>
            <span class="c1">#         try:</span>
            <span class="c1">#             ordered.append(window_mat[pos, :])</span>
            <span class="c1">#         except:</span>
            <span class="c1">#             # for sequences of len &lt; 18 adding dummy vector with 2s, length of descriptor dimensions</span>
            <span class="c1">#             ordered.append([2] * desc_dim)</span>
            <span class="c1">#     ordered = np.asarray(ordered)</span>
			<span class="c1">#</span>
            <span class="c1">#     window_arc = []</span>
			<span class="c1">#</span>
            <span class="c1">#     # loop through pharmacophoric features</span>
            <span class="c1">#     for m in range(desc_dim):</span>
            <span class="c1">#         all_arcs = []  # stores all arcs that can be found of a pharmacophoric feature</span>
            <span class="c1">#         arc = 0</span>
			<span class="c1">#</span>
            <span class="c1">#         for n in range(18):  # for all positions in helix, regardless of sequence length</span>
            <span class="c1">#             if ordered[n, m] == 0:  # if position does not contain pharmacophoric feature</span>
            <span class="c1">#                 all_arcs.append(arc)  # append previous arc to all arcs list</span>
            <span class="c1">#                 arc = 0  # arc is initialized</span>
            <span class="c1">#             elif ordered[n, m] == 1:  # if position contains pharmacophoric feature(PF), elongate arc by 20Â°</span>
            <span class="c1">#                 arc += 20</span>
            <span class="c1">#             elif ordered[n, m] == 2:  # if position doesn&#39;t contain amino acid:</span>
            <span class="c1">#                 if ordered[n - 1, m] == 1:  # if previous position contained PF add 10Â°</span>
            <span class="c1">#                     arc += 10</span>
            <span class="c1">#                 elif ordered[n - 1, m] == 0:  # if previous position didn&#39;t contain PF don&#39;t add anything</span>
            <span class="c1">#                     arc += 0</span>
            <span class="c1">#                 elif ordered[</span>
            <span class="c1">#                             n - 2, m] == 1:  # if previous position is empty then check second previous for PF</span>
            <span class="c1">#                     arc += 10</span>
            <span class="c1">#                 if n == 17:  # if we are at the last position check for position n=0 instead of next position.</span>
            <span class="c1">#                     if ordered[0, m] == 1:  # if it contains PF add 10Â° extra</span>
            <span class="c1">#                         arc += 10</span>
            <span class="c1">#                 else:  # if next position contains PF add 10Â° extra</span>
            <span class="c1">#                     if ordered[n + 1, m] == 1:</span>
            <span class="c1">#                         arc += 10</span>
            <span class="c1">#                     elif ordered[n + 1, m] == 0:</span>
            <span class="c1">#                         arc += 0</span>
            <span class="c1">#                     else:  # if next position is empty check for 2nd next position</span>
            <span class="c1">#                         if n == 16:</span>
            <span class="c1">#                             if ordered[0, m] == 1:</span>
            <span class="c1">#                                 arc += 10</span>
            <span class="c1">#                         else:</span>
            <span class="c1">#                             if ordered[n + 2, m] == 1:</span>
            <span class="c1">#                                 arc += 10</span>
			<span class="c1">#</span>
            <span class="c1">#         all_arcs.append(arc)</span>
            <span class="c1">#         if not arc == 360:</span>
            <span class="c1">#             arc0 = all_arcs.pop() + all_arcs[0]  # join first and last arc together</span>
            <span class="c1">#             all_arcs = [arc0] + all_arcs[1:]</span>
			<span class="c1">#</span>
            <span class="c1">#         window_arc.append(np.max(all_arcs))  # append to window arcs the maximum arc of this PF</span>
            <span class="c1">#     allwindows_arc.append(window_arc)  # append all PF arcs of this window</span>
			<span class="c1">#</span>
            <span class="c1"># allwindows_arc = np.asarray(allwindows_arc)</span>
			<span class="c1">#</span>
            <span class="c1"># if modality == &#39;max&#39;:</span>
            <span class="c1">#     final_arc = np.max(allwindows_arc, axis=0)  # calculate maximum / mean arc along all windows</span>
            <span class="c1"># elif modality == &#39;mean&#39;:</span>
            <span class="c1">#     final_arc = np.mean(allwindows_arc, axis=0)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     print(&#39;modality is unknown, please choose between &quot;max&quot; and &quot;mean&quot;\n.&#39;)</span>
            <span class="c1">#     sys.exit()</span>

            <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span></div></div>








</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ana Marta Sequeira

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>